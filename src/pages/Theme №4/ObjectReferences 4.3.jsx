import { Badge, Container } from 'react-bootstrap'
import { FaInfoCircle } from 'react-icons/fa'
import ArrowNavigator from '../../components/ArrowNavigator.jsx'
import CodeNote from '../../components/CodeNote.jsx'

export default function GarbageCollection() {
  return (
    <Container className='text-light mt-5 mb-5'>
      <ArrowNavigator />
      <h1>Сборка мусора</h1>

      <p>
        Управление памятью в JavaScript выполняется автоматически и незаметно. 
        Мы создаём примитивы, объекты, функции… Всё это занимает память.
      </p>

      <p>
        Но что происходит, когда что-то больше не нужно? Как движок JavaScript 
        обнаруживает, что пора очищать память?
      </p>

      <h2>Достижимость</h2>
      <p>
        Основной концепцией управления памятью в JavaScript является принцип достижимости.
      </p>
      <p>
        Если упростить, то «достижимые» значения – это те, которые доступны или используются. 
        Они гарантированно находятся в памяти.
      </p>
      <p>
        Существует базовое множество достижимых значений, которые не могут быть удалены.
      </p>
      <p>Например:</p>
      <ul>
        <li>Выполняемая в данный момент функция, её локальные переменные и параметры.</li>
        <li>Другие функции в текущей цепочке вложенных вызовов, их локальные переменные и параметры.</li>
        <li>Глобальные переменные.</li>
        <li>(некоторые другие внутренние значения)</li>
      </ul>
      <p>Эти значения мы будем называть <strong>корнями</strong>.</p>
      <p>
        Любое другое значение считается достижимым, если оно доступно из корня 
        по ссылке или по цепочке ссылок.
      </p>
      <p>
        Например, если в глобальной переменной есть объект, и он имеет свойство, 
        в котором хранится ссылка на другой объект, то этот объект считается достижимым. 
        И те, на которые он ссылается, тоже достижимы.
      </p>
      <p>
        В движке JavaScript есть фоновый процесс, который называется <strong>сборщиком мусора</strong>. 
        Он отслеживает все объекты и удаляет те, которые стали недоступными.
      </p>

      <h2>Простой пример</h2>
      <p>Вот самый простой пример:</p>
      <CodeNote
        js={`// в user находится ссылка на объект
let user = {
  name: "John"
};`}
      />
      <p>
        Здесь стрелка обозначает ссылку на объект. Глобальная переменная{' '}
        <Badge bg='secondary'>user</Badge> ссылается на объект{' '}
        <Badge bg='secondary'>{`{name: "John"}`}</Badge> (мы будем называть его просто «John» для краткости).
      </p>
      <p>
        Если перезаписать значение <Badge bg='secondary'>user</Badge>, то ссылка потеряется:
      </p>
      <CodeNote js={`user = null;`} />
      <p>
        Теперь объект John становится недостижимым. К нему нет доступа, на него нет ссылок. 
        Сборщик мусора удалит эти данные и освободит память.
      </p>

      <h3>Две ссылки</h3>
      <p>
        Представим, что мы скопировали ссылку из <Badge bg='secondary'>user</Badge> в{' '}
        <Badge bg='secondary'>admin</Badge>:
      </p>
      <CodeNote
        js={`// в user находится ссылка на объект
let user = {
  name: "John"
};

let admin = user;`}
      />
      <p>Теперь, если мы сделаем то же самое:</p>
      <CodeNote js={`user = null;`} />
      <p>
        …то объект John всё ещё достижим через глобальную переменную{' '}
        <Badge bg='secondary'>admin</Badge>, поэтому он находится в памяти. 
        Если бы мы также перезаписали <Badge bg='secondary'>admin</Badge>, 
        то John был бы удалён.
      </p>

      <h3>Взаимосвязанные объекты</h3>
      <p>Теперь более сложный пример. Семья:</p>
      <CodeNote
        js={`function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
});`}
      />
      <p>
        Функция <Badge bg='secondary'>marry</Badge> «женит» два объекта, 
        давая им ссылки друг на друга, и возвращает новый объект, 
        содержащий ссылки на два предыдущих.
      </p>
      <p>На данный момент все объекты достижимы.</p>
      <p>Теперь удалим две ссылки:</p>
      <CodeNote
        js={`delete family.father;
delete family.mother.husband;`}
      />
      <p>
        Недостаточно удалить только одну из этих двух ссылок, потому что 
        все объекты останутся достижимыми.
      </p>
      <p>
        Но если мы удалим обе, то увидим, что у объекта John больше нет входящих ссылок.
      </p>

      <div
        style={{
          border: '5px solid rgb(49, 49, 49)',
          borderRadius: '10px',
          margin: '40px 0',
          padding: '20px',
        }}
      >
        <h1
          style={{
            fontSize: '1.3rem',
            fontFamily: 'monospace',
            fontWeight: 'bold',
          }}
        >
          <FaInfoCircle
            style={{
              position: 'relative',
              bottom: '2px',
              margin: '5px',
              color: '#3463ff',
            }}
          />
          Важно помнить
        </h1>
        <p>
          Исходящие ссылки не имеют значения. Только входящие ссылки могут 
          сделать объект достижимым.
        </p>
      </div>

      <p>
        Объект John теперь недостижим и будет удалён из памяти со всеми своими данными, 
        которые также стали недоступны.
      </p>

      <h3>Недостижимый «остров»</h3>
      <p>
        Вполне возможна ситуация, при которой целый «остров» взаимосвязанных 
        объектов может стать недостижимым и удалиться из памяти.
      </p>
      <p>
        Возьмём объект <Badge bg='secondary'>family</Badge> из примера выше. А затем:
      </p>
      <CodeNote js={`family = null;`} />
      <p>Этот пример демонстрирует, насколько важна концепция достижимости.</p>
      <p>
        Объекты John и Ann всё ещё связаны, оба имеют входящие ссылки, 
        но этого недостаточно.
      </p>
      <p>
        Бывший объект <Badge bg='secondary'>family</Badge> был отсоединён от корня, 
        на него больше нет ссылки, поэтому весь «остров» становится недостижимым 
        и будет удалён.
      </p>

      <h2>Внутренние алгоритмы</h2>
      <p>
        Основной алгоритм сборки мусора называется <strong>«алгоритм пометок»</strong>{' '}
        (от англ. «mark-and-sweep»).
      </p>
      <p>
        Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:
      </p>
      <ol>
        <li>Сборщик мусора «помечает» (запоминает) все корневые объекты.</li>
        <li>Затем он идёт по ним и «помечает» все ссылки из них.</li>
        <li>Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.</li>
        <li>…И так далее, пока не будут посещены все достижимые (из корней) ссылки.</li>
        <li>Все непомеченные объекты удаляются.</li>
      </ol>

      <p>
        Мы также можем представить себе этот процесс как выливание огромного 
        ведра краски из корней, которая течёт по всем ссылкам и отмечает все 
        достижимые объекты. Затем непомеченные удаляются.
      </p>

      <h3>Оптимизации</h3>
      <p>
        Это концепция того, как работает сборка мусора. Движки JavaScript 
        применяют множество оптимизаций, чтобы она работала быстрее и не 
        задерживала выполнение кода.
      </p>
      <p>Вот некоторые из оптимизаций:</p>

      <div
        style={{
          border: '2px solid rgb(108, 117, 125)',
          borderRadius: '8px',
          margin: '20px 0',
          padding: '20px',
          backgroundColor: 'rgba(108, 117, 125, 0.1)',
        }}
      >
        <h4>
          <Badge bg='info'>Сборка по поколениям</Badge> (Generational collection)
        </h4>
        <p>
          Объекты делятся на два набора: «новые» и «старые». В типичном коде 
          многие объекты имеют короткую жизнь: они появляются, выполняют свою 
          работу и быстро умирают, так что имеет смысл отслеживать новые объекты 
          и, если это так, быстро очищать от них память.
        </p>
      </div>

      <div
        style={{
          border: '2px solid rgb(108, 117, 125)',
          borderRadius: '8px',
          margin: '20px 0',
          padding: '20px',
          backgroundColor: 'rgba(108, 117, 125, 0.1)',
        }}
      >
        <h4>
          <Badge bg='warning'>Инкрементальная сборка</Badge> (Incremental collection)
        </h4>
        <p>
          Если объектов много, и мы пытаемся обойти и пометить весь набор объектов 
          сразу, это может занять некоторое время и привести к видимым задержкам 
          в выполнении скрипта. Так что движок делит всё множество объектов на 
          части, и далее очищает их одну за другой.
        </p>
      </div>

      <div
        style={{
          border: '2px solid rgb(108, 117, 125)',
          borderRadius: '8px',
          margin: '20px 0',
          padding: '20px',
          backgroundColor: 'rgba(108, 117, 125, 0.1)',
        }}
      >
        <h4>
          <Badge bg='success'>Сборка в свободное время</Badge> (Idle-time collection)
        </h4>
        <p>
          Чтобы уменьшить возможное влияние на производительность, сборщик 
          мусора старается работать только во время простоя процессора.
        </p>
      </div>

      <h1 className='mt-5'>Итого</h1>
      <p>Главное, что нужно знать:</p>
      <ul>
        <li>Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.</li>
        <li>Объекты сохраняются в памяти, пока они достижимы.</li>
        <li>
          Если на объект есть ссылка – вовсе не факт, что он является достижимым (из корня): 
          набор взаимосвязанных объектов может стать недоступен в целом.
        </li>
      </ul>
      <p>Современные движки реализуют разные продвинутые алгоритмы сборки мусора.</p>

      <div
        style={{
          border: '2px solid rgb(108, 117, 125)',
          borderRadius: '8px',
          margin: '20px 0',
          padding: '20px',
          backgroundColor: 'rgba(108, 117, 125, 0.1)',
        }}
      >
        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
          <thead>
            <tr>
              <th
                style={{
                  padding: '10px',
                  borderBottom: '1px solid #6c757d',
                  textAlign: 'left',
                }}
              >
                Понятие
              </th>
              <th
                style={{
                  padding: '10px',
                  borderBottom: '1px solid #6c757d',
                  textAlign: 'left',
                }}
              >
                Описание
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style={{ padding: '8px', borderBottom: '1px solid #495057' }}>
                <Badge bg='secondary'>Достижимость</Badge>
              </td>
              <td style={{ padding: '8px', borderBottom: '1px solid #495057' }}>
                Объект доступен из корня по ссылке или цепочке ссылок
              </td>
            </tr>
            <tr>
              <td style={{ padding: '8px', borderBottom: '1px solid #495057' }}>
                <Badge bg='secondary'>Корни</Badge>
              </td>
              <td style={{ padding: '8px', borderBottom: '1px solid #495057' }}>
                Базовые значения, которые всегда достижимы
              </td>
            </tr>
            <tr>
              <td style={{ padding: '8px' }}>
                <Badge bg='secondary'>Mark-and-sweep</Badge>
              </td>
              <td style={{ padding: '8px' }}>
                Основной алгоритм сборки мусора
              </td>
            </tr>
          </tbody>
        </table>
      </div>

      <div
        style={{
          border: '5px solid rgb(49, 49, 49)',
          borderRadius: '10px',
          margin: '40px 0',
          padding: '20px',
        }}
      >
        <h1
          style={{
            fontSize: '1.2rem',
            fontFamily: 'monospace',
            fontWeight: 'bold',
          }}
        >
          <FaInfoCircle
            style={{
              position: 'relative',
              bottom: '2px',
              margin: '5px',
              color: '#3463ff',
            }}
          />
          Для углубленного изучения
        </h1>
        <p>
          Если вы знакомы с низкоуровневым программированием, то более подробная 
          информация о сборщике мусора V8 находится в статье «A tour of V8: Garbage Collection».
        </p>
        <p>
          Глубокое понимание работы движков полезно, когда вам нужна низкоуровневая 
          оптимизация. Было бы разумно запланировать их изучение как следующий шаг 
          после того, как вы познакомитесь с языком.
        </p>
      </div>
    </Container>
  )
}