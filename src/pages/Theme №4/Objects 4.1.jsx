import { Badge, Container } from 'react-bootstrap'
import { FaInfoCircle } from 'react-icons/fa'
import ArrowNavigator from '../../components/ArrowNavigator.jsx'
import CodeJs from '../../components/CodeJs.jsx'
import CodeNote from '../../components/CodeNote.jsx'
import TaskViewer from '../../components/TaskViewer/TaskViewer.jsx'

import { tasks } from '../../data/tasks.js'

export default function Objects() {
  return (
    <Container className='text-light mt-5 mb-5'>
      <ArrowNavigator />
      <h1>Объекты</h1>

      <p>
        Как мы знаем из главы Типы данных, в JavaScript существует 8 типов данных. 
        Семь из них называются «примитивными», так как содержат только одно значение 
        (будь то строка, число или что-то другое).
      </p>

      <p>
        Объекты же используются для хранения коллекций различных значений и более 
        сложных сущностей. В JavaScript объекты используются очень часто, это одна из 
        основ языка. Поэтому мы должны понять их, прежде чем углубляться куда-либо ещё.
      </p>

      <p>
        Объект может быть создан с помощью фигурных скобок{' '}
        <Badge bg='secondary'>{'{ … }'}</Badge> с необязательным списком свойств. 
        Свойство – это пара «ключ: значение», где ключ – это строка (также называемая 
        «именем свойства»), а значение может быть чем угодно.
      </p>

      <p>
        Мы можем представить объект в виде ящика с подписанными папками. Каждый 
        элемент данных хранится в своей папке, на которой написан ключ. По ключу 
        папку легко найти, удалить или добавить в неё что-либо.
      </p>

      <p>
        Пустой объект («пустой ящик») можно создать, используя один из двух вариантов синтаксиса:
      </p>

      <CodeJs
        js={`let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"`}
      />

      <p>
        Обычно используют вариант с фигурными скобками <Badge bg='secondary'>{'{ … }'}</Badge>. 
        Такое объявление называют литералом объекта или литеральной нотацией.
      </p>

      <h2>Литералы и свойства</h2>

      <p>
        При использовании литерального синтаксиса <Badge bg='secondary'>{'{ … }'}</Badge> мы 
        сразу можем поместить в объект несколько свойств в виде пар «ключ: значение»:
      </p>

      <CodeJs
        js={`let user = {     // объект
  name: "John",  // под ключом "name" хранится значение "John"
  age: 30        // под ключом "age" хранится значение 30
};`}
      />

      <p>
        У каждого свойства есть ключ (также называемый «имя» или «идентификатор»). 
        После имени свойства следует двоеточие <Badge bg='secondary'>{'":"'}</Badge>, и 
        затем указывается значение свойства. Если в объекте несколько свойств, то они 
        перечисляются через запятую.
      </p>

      <p>В объекте user сейчас находятся два свойства:</p>
      <ul>
        <li>Первое свойство с именем <Badge bg='secondary'>{'"name"'}</Badge> и значением <Badge bg='secondary'>{'"John"'}</Badge>.</li>
        <li>Второе свойство с именем <Badge bg='secondary'>{'"age"'}</Badge> и значением <Badge bg='secondary'>30</Badge>.</li>
      </ul>

      <p>
        Можно сказать, что наш объект user – это ящик с двумя папками, подписанными 
        «name» и «age».
      </p>

      <p>
        Мы можем в любой момент добавить в него новые папки, удалить папки или прочитать 
        содержимое любой папки.
      </p>

      <p>Для обращения к свойствам используется запись «через точку»:</p>

      <CodeJs
        js={`// получаем свойства объекта:
alert( user.name ); // John
alert( user.age ); // 30`}
      />

      <p>Значение может быть любого типа. Давайте добавим свойство с логическим значением:</p>

      <CodeJs js={`user.isAdmin = true;`} />

      <p>Для удаления свойства мы можем использовать оператор <Badge bg='secondary'>delete</Badge>:</p>

      <CodeJs js={`delete user.age;`} />

      <p>
        Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:
      </p>

      <CodeJs
        js={`let user = {
  name: "John",
  age: 30,
  "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
};`}
      />

      <p>Последнее свойство объекта может заканчиваться запятой:</p>

      <CodeJs
        js={`let user = {
  name: "John",
  age: 30,
}`}
      />

      <p>
        Это называется «висячая запятая». Такой подход упрощает добавление, удаление и 
        перемещение свойств, так как все строки объекта становятся одинаковыми.
      </p>

      <div
        style={{
          border: '5px solid rgb(49, 49, 49)',
          borderRadius: '10px',
          margin: '40px 0',
          padding: '20px',
        }}
      >
        <h1
          style={{
            fontSize: '1.3rem',
            fontFamily: 'monospace',
            fontWeight: 'bold',
          }}
        >
          <FaInfoCircle
            style={{
              position: 'relative',
              bottom: '2px',
              margin: '5px',
              color: '#3463ff',
            }}
          />
          Объект, объявленный как константа, может быть изменён
        </h1>
        <p>
          Объект, объявленный через <Badge bg='secondary'>const</Badge>, может быть изменён.
        </p>
        <CodeJs
          js={`const user = {
  name: "John"
};

user.name = "Pete"; // (*)

alert(user.name); // Pete`}
        />
        <p>
          Может показаться, что строка (*) должна вызвать ошибку, но нет, здесь всё в порядке. 
          Дело в том, что объявление <Badge bg='secondary'>const</Badge> защищает от изменений 
          только саму переменную <Badge bg='secondary'>user</Badge>, а не её содержимое.
        </p>
        <p>
          Определение <Badge bg='secondary'>const</Badge> выдаст ошибку только если мы присвоим 
          переменной другое значение: <Badge bg='secondary'>user=...</Badge>.
        </p>
      </div>

      <h2>Квадратные скобки</h2>

      <p>
        Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает:
      </p>

      <CodeJs
        js={`// это вызовет синтаксическую ошибку
user.likes birds = true`}
      />

      <p>
        JavaScript видит, что мы обращаемся к свойству <Badge bg='secondary'>user.likes</Badge>, 
        а затем идёт непонятное слово <Badge bg='secondary'>birds</Badge>. В итоге синтаксическая ошибка.
      </p>

      <p>
        Точка требует, чтобы ключ был именован по правилам именования переменных. То есть не имел 
        пробелов, не начинался с цифры и не содержал специальные символы, кроме{' '}
        <Badge bg='secondary'>$</Badge> и <Badge bg='secondary'>_</Badge>.
      </p>

      <p>
        Для таких случаев существует альтернативный способ доступа к свойствам через квадратные 
        скобки. Такой способ сработает с любым именем свойства:
      </p>

      <CodeJs
        js={`let user = {};

// присваивание значения свойству
user["likes birds"] = true;

// получение значения свойства
alert(user["likes birds"]); // true

// удаление свойства
delete user["likes birds"];`}
      />

      <p>
        Сейчас всё в порядке. Обратите внимание, что строка в квадратных скобках заключена в 
        кавычки (подойдёт любой тип кавычек).
      </p>

      <p>
        Квадратные скобки также позволяют обратиться к свойству, имя которого может быть 
        результатом выражения. Например, имя свойства может храниться в переменной:
      </p>

      <CodeJs
        js={`let key = "likes birds";

// то же самое, что и user["likes birds"] = true;
user[key] = true;`}
      />

      <p>
        Здесь переменная <Badge bg='secondary'>key</Badge> может быть вычислена во время 
        выполнения кода или зависеть от пользовательского ввода. После этого мы используем 
        её для доступа к свойству. Это даёт нам большую гибкость.
      </p>

      <p>Пример:</p>

      <CodeJs
        js={`let user = {
  name: "John",
  age: 30
};

let key = prompt("Что вы хотите узнать о пользователе?", "name");

// доступ к свойству через переменную
alert( user[key] ); // John (если ввели "name")`}
      />

      <p>Запись «через точку» такого не позволяет:</p>

      <CodeJs
        js={`let user = {
  name: "John",
  age: 30
};

let key = "name";
alert( user.key ); // undefined`}
      />

      <h3>Вычисляемые свойства</h3>

      <p>
        Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.
      </p>

      <p>Пример:</p>

      <CodeJs
        js={`let fruit = prompt("Какой фрукт купить?", "apple");

let bag = {
  [fruit]: 5, // имя свойства будет взято из переменной fruit
};

alert( bag.apple ); // 5, если fruit="apple"`}
      />

      <p>
        Смысл вычисляемого свойства прост: запись <Badge bg='secondary'>[fruit]</Badge> означает, 
        что имя свойства необходимо взять из переменной <Badge bg='secondary'>fruit</Badge>.
      </p>

      <p>
        И если посетитель введёт слово <Badge bg='secondary'>{'"apple"'}</Badge>, то в объекте 
        <Badge bg='secondary'>bag</Badge> теперь будет лежать свойство{' '}
        <Badge bg='secondary'>{'{ apple: 5 }'}</Badge>.
      </p>

      <p>По сути, пример выше работает так же, как и следующий пример:</p>

      <CodeJs
        js={`let fruit = prompt("Какой фрукт купить?", "apple");
let bag = {};

// имя свойства будет взято из переменной fruit
bag[fruit] = 5;`}
      />

      <p>…Но первый пример выглядит лаконичнее.</p>

      <p>Мы можем использовать и более сложные выражения в квадратных скобках:</p>

      <CodeJs
        js={`let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};`}
      />

      <h3>Свойство из переменной</h3>

      <p>
        В реальном коде часто нам необходимо использовать существующие переменные как значения 
        для свойств с тем же именем.
      </p>

      <p>Например:</p>

      <CodeJs
        js={`function makeUser(name, age) {
  return {
    name: name,
    age: age
    // ...другие свойства
  };
}

let user = makeUser("John", 30);
alert(user.name); // John`}
      />

      <p>
        В примере выше название свойств <Badge bg='secondary'>name</Badge> и{' '}
        <Badge bg='secondary'>age</Badge> совпадают с названиями переменных, которые мы 
        подставляем в качестве значений этих свойств. Такой подход настолько распространён, 
        что существуют специальные короткие свойства для упрощения этой записи.
      </p>

      <p>
        Вместо <Badge bg='secondary'>name:name</Badge> мы можем написать просто{' '}
        <Badge bg='secondary'>name</Badge>:
      </p>

      <CodeJs
        js={`function makeUser(name, age) {
  return {
    name, // то же самое, что и name: name
    age   // то же самое, что и age: age
    // ...
  };
}`}
      />

      <p>Мы можем использовать как обычные свойства, так и короткие в одном и том же объекте:</p>

      <CodeJs
        js={`let user = {
  name,  // тоже самое, что и name:name
  age: 30
};`}
      />

      <h3>Ограничения на имена свойств</h3>

      <p>
        Как мы уже знаем, имя переменной не может совпадать с зарезервированными словами, 
        такими как <Badge bg='secondary'>{'"for"'}</Badge>, <Badge bg='secondary'>{'"let"'}</Badge>,{' '}
        <Badge bg='secondary'>{'"return"'}</Badge> и т.д.
      </p>

      <p>Но для свойств объекта такого ограничения нет:</p>

      <CodeJs
        js={`// эти имена свойств допустимы
let obj = {
  for: 1,
  let: 2,
  return: 3
};

alert( obj.for + obj.let + obj.return );  // 6`}
      />

      <p>
        Иными словами, нет никаких ограничений к именам свойств. Они могут быть в виде строк 
        или символов (специальный тип для идентификаторов, который будет рассмотрен позже).
      </p>

      <p>Все другие типы данных будут автоматически преобразованы к строке.</p>

      <p>
        Например, если использовать число <Badge bg='secondary'>0</Badge> в качестве ключа, 
        то оно превратится в строку <Badge bg='secondary'>{'"0"'}</Badge>:
      </p>

      <CodeJs
        js={`let obj = {
  0: "Тест" // то же самое что и "0": "Тест"
};

// обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
alert( obj["0"] ); // Тест
alert( obj[0] ); // Тест (то же свойство)`}
      />

      <div
        style={{
          border: '5px solid rgb(49, 49, 49)',
          borderRadius: '10px',
          margin: '40px 0',
          padding: '20px',
        }}
      >
        <h1
          style={{
            fontSize: '1.3rem',
            fontFamily: 'monospace',
            fontWeight: 'bold',
          }}
        >
          <FaInfoCircle
            style={{
              position: 'relative',
              bottom: '2px',
              margin: '5px',
              color: '#3463ff',
            }}
          />
          Особенность свойства __proto__
        </h1>
        <p>
          Есть небольшой подводный камень, связанный со специальным свойством{' '}
          <Badge bg='secondary'>__proto__</Badge>. Мы не можем установить его в необъектное значение:
        </p>
        <CodeJs
          js={`let obj = {};
obj.__proto__ = 5; // присвоим число
alert(obj.__proto__); // [object Object], значение - это объект, т.е. не то, что мы ожидали`}
        />
        <p>Как мы видим, присвоение примитивного значения 5 игнорируется.</p>
      </div>

      <h2>Проверка существования свойства, оператор «in»</h2>

      <p>
        В отличие от многих других языков, особенность JavaScript-объектов в том, что можно 
        получить доступ к любому свойству. Даже если свойства не существует – ошибки не будет!
      </p>

      <p>
        При обращении к свойству, которого нет, возвращается <Badge bg='secondary'>undefined</Badge>. 
        Это позволяет просто проверить существование свойства:
      </p>

      <CodeJs
        js={`let user = {};

alert( user.noSuchProperty === undefined ); // true означает "свойства нет"`}
      />

      <p>
        Также существует специальный оператор <Badge bg='secondary'>{'"in"'}</Badge> для проверки 
        существования свойства в объекте.
      </p>

      <p>Синтаксис оператора:</p>

      <CodeNote js={`"key" in object`} />

      <p>Пример:</p>

      <CodeJs
        js={`let user = { name: "John", age: 30 };

alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует`}
      />

      <p>
        Обратите внимание, что слева от оператора <Badge bg='secondary'>in</Badge> должно быть 
        имя свойства. Обычно это строка в кавычках.
      </p>

      <p>
        Если мы опускаем кавычки, это значит, что мы указываем переменную, в которой находится 
        имя свойства. Например:
      </p>

      <CodeJs
        js={`let user = { age: 30 };

let key = "age";
alert( key in user ); // true, имя свойства было взято из переменной key`}
      />

      <p>
        Для чего вообще нужен оператор <Badge bg='secondary'>in</Badge>? Разве недостаточно 
        сравнения с <Badge bg='secondary'>undefined</Badge>?
      </p>

      <p>
        В большинстве случаев прекрасно сработает сравнение с <Badge bg='secondary'>undefined</Badge>. 
        Но есть особый случай, когда оно не подходит и нужно использовать <Badge bg='secondary'>{'"in"'}</Badge>.
      </p>

      <p>
        Это когда свойство существует, но содержит значение <Badge bg='secondary'>undefined</Badge>:
      </p>

      <CodeJs
        js={`let obj = {
  test: undefined
};

alert( obj.test ); //  выведет undefined, значит свойство не существует?
alert( "test" in obj ); // true, свойство существует!`}
      />

      <p>
        В примере выше свойство <Badge bg='secondary'>obj.test</Badge> технически существует в объекте. 
        Оператор <Badge bg='secondary'>in</Badge> сработал правильно.
      </p>

      <p>
        Подобные ситуации случаются очень редко, так как <Badge bg='secondary'>undefined</Badge> обычно 
        явно не присваивается. Для «неизвестных» или «пустых» свойств мы используем значение{' '}
        <Badge bg='secondary'>null</Badge>.
      </p>

      <h2>Цикл {'"for..in"'}</h2>

      <p>
        Для перебора всех свойств объекта используется цикл <Badge bg='secondary'>for..in</Badge>. 
        Этот цикл отличается от изученного ранее цикла <Badge bg='secondary'>for(;;)</Badge>.
      </p>

      <p>Синтаксис:</p>

      <CodeNote js={`for (key in object) {
  // тело цикла выполняется для каждого свойства объекта
}`} />

      <p>К примеру, давайте выведем все свойства объекта <Badge bg='secondary'>user</Badge>:</p>

      <CodeJs
        js={`let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}`}
      />

      <p>
        Обратите внимание, что все конструкции «for» позволяют нам объявлять переменную внутри цикла, 
        как, например, <Badge bg='secondary'>let key</Badge> здесь.
      </p>

      <p>
        Кроме того, мы могли бы использовать другое имя переменной. Например, часто используется 
        вариант <Badge bg='secondary'>{'"for (let prop in obj)"'}</Badge>.
      </p>

      <h3>Упорядочение свойств объекта</h3>

      <p>
        Упорядочены ли свойства объекта? Другими словами, если мы будем в цикле перебирать все 
        свойства объекта, получим ли мы их в том же порядке, в котором мы их добавляли? 
        Можем ли мы на это рассчитывать?
      </p>

      <p>
        Короткий ответ: свойства упорядочены особым образом: свойства с целочисленными ключами 
        сортируются по возрастанию, остальные располагаются в порядке создания. Разберёмся подробнее.
      </p>

      <p>В качестве примера рассмотрим объект с телефонными кодами:</p>

      <CodeJs
        js={`let codes = {
  "49": "Германия",
  "41": "Швейцария",
  "44": "Великобритания",
  // ..,
  "1": "США"
};

for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}`}
      />

      <p>
        Если мы делаем сайт для немецкой аудитории, то, вероятно, мы хотим, чтобы код 49 был первым.
      </p>

      <p>Но если мы запустим код, мы увидим совершенно другую картину:</p>

      <ul>
        <li>США (1) идёт первым</li>
        <li>затем Швейцария (41) и так далее.</li>
      </ul>

      <p>
        Телефонные коды идут в порядке возрастания, потому что они являются целыми числами: 
        1, 41, 44, 49.
      </p>

      <div
        style={{
          border: '5px solid rgb(49, 49, 49)',
          borderRadius: '10px',
          margin: '40px 0',
          padding: '20px',
        }}
      >
        <h1
          style={{
            fontSize: '1.3rem',
            fontFamily: 'monospace',
            fontWeight: 'bold',
          }}
        >
          <FaInfoCircle
            style={{
              position: 'relative',
              bottom: '2px',
              margin: '5px',
              color: '#3463ff',
            }}
          />
          Целочисленные свойства
        </h1>
        <p>
          Термин «целочисленное свойство» означает строку, которая может быть преобразована в 
          целое число и обратно без изменений.
        </p>
        <p>
          То есть, <Badge bg='secondary'>{'"49"'}</Badge> – это целочисленное имя свойства, потому 
          что если его преобразовать в целое число, а затем обратно в строку, то оно не изменится. 
          А вот свойства <Badge bg='secondary'>{'"+49"'}</Badge> или <Badge bg='secondary'>{'"1.2"'}</Badge> таковыми не являются.
        </p>
        <CodeJs
          js={`// Math.trunc - встроенная функция, которая удаляет десятичную часть
alert( String(Math.trunc(Number("49"))) ); // "49", то же самое ⇒ свойство целочисленное
alert( String(Math.trunc(Number("+49"))) ); // "49", не то же самое, что "+49" ⇒ свойство не целочисленное
alert( String(Math.trunc(Number("1.2"))) ); // "1", не то же самое, что "1.2" ⇒ свойство не целочисленное`}
        />
      </div>

      <p>
        …С другой стороны, если ключи не целочисленные, то они перебираются в порядке создания, например:
      </p>

      <CodeJs
        js={`let user = {
  name: "John",
  surname: "Smith"
};
user.age = 25; // добавим ещё одно свойство

// не целочисленные свойства перечислены в порядке создания
for (let prop in user) {
  alert( prop ); // name, surname, age
}`}
      />

      <p>
        Таким образом, чтобы решить нашу проблему с телефонными кодами, мы можем схитрить, сделав 
        коды не целочисленными свойствами. Добавления знака <Badge bg='secondary'>{'"+"'}</Badge> перед 
        каждым кодом будет достаточно.
      </p>

      <p>Пример:</p>

      <CodeJs
        js={`let codes = {
  "+49": "Германия",
  "+41": "Швейцария",
  "+44": "Великобритания",
  // ..,{''}
  "+1": "США"
};

for (let code in codes) {
  alert( +code ); // 49, 41, 44, 1
}`}
      />

      <p>Теперь код работает так, как мы задумывали.</p>

      <h1 className='mt-5'>Итого</h1>

      <p>
        Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
      </p>

      <p>Они хранят свойства (пары ключ-значение), где:</p>

      <ul>
        <li>Ключи свойств должны быть строками или символами (обычно строками).</li>
        <li>Значения могут быть любого типа.</li>
      </ul>

      <p>Чтобы получить доступ к свойству, мы можем использовать:</p>

      <ul>
        <li>Запись через точку: <Badge bg='secondary'>obj.property</Badge>.</li>
        <li>
          Квадратные скобки <Badge bg='secondary'>obj{'["property"]'}</Badge>. Квадратные скобки 
          позволяют взять ключ из переменной, например, <Badge bg='secondary'>obj[varWithKey]</Badge>.
        </li>
      </ul>

      <p>Дополнительные операторы:</p>

      <ul>
        <li>Удаление свойства: <Badge bg='secondary'>delete obj.prop</Badge>.</li>
        <li>Проверка существования свойства: <Badge bg='secondary'>{'"key"'} in obj</Badge>.</li>
        <li>Перебор свойств объекта: цикл <Badge bg='secondary'>for (let key in obj)</Badge>.</li>
      </ul>

      <p>
        То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object.
      </p>

      <p>
        В JavaScript есть много других типов объектов:
      </p>

      <ul>
        <li><Badge bg='secondary'>Array</Badge> для хранения упорядоченных коллекций данных,</li>
        <li><Badge bg='secondary'>Date</Badge> для хранения информации о дате и времени,</li>
        <li><Badge bg='secondary'>Error</Badge> для хранения информации об ошибке.</li>
        <li>… и так далее.</li>
      </ul>

      <p>
        У них есть свои особенности, которые мы изучим позже. Иногда люди говорят что-то вроде «тип данных Array» или «тип данных Date», но формально они не являются отдельными типами, а относятся к типу данных Object. Они лишь расширяют его различными способами.
      </p>

      <p>
        Объекты в JavaScript очень мощные. Здесь мы только немного углубились в действительно огромную тему. Мы будем плотно работать с объектами и узнаем о них больше в следующих частях учебника.
      </p>

				<TaskViewer tasks={tasks['4.1']} />

    </Container>
  );
}